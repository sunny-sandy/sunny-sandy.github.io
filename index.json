[{"categories":null,"content":" 最大升序数组和 ","date":"2022-10-07","objectID":"/dr/:0:0","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"题目 给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。 子数组是数组中的一个连续数字序列。 已知子数组 [numsl, numsl+1, …, numsr-1, numsr] ，若对所有 i（l \u003c= i \u003c r），numsi \u003c numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。 示例 1： 输入：nums = [10,20,30,5,10,50] 输出：65 解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。 示例 2： 输入：nums = [10,20,30,40,50] 输出：150 解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 示例 3： 输入：nums = [12,17,15,13,10,11,12] 输出：33 解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 示例 4： 输入：nums = [100,10,1] 输出：100 提示： 1 \u003c= nums.length \u003c= 100 1 \u003c= nums[i] \u003c= 100 ","date":"2022-10-07","objectID":"/dr/:1:0","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"分析 首先要注意临界条件，是从第一个开始临界最后还是从第二个开始临界第一个呢？ 因为最大数组的临界和最后一个的临界可能会在一起（），所以把临界放到最前面 又因为单个的数也可能算作最大数组，因此第一个刚好可以作为初始化max的值 注意用while循环求数组和的时候最后一个无论如何都是要加的，所以最后不用再判断i是否是nums.length-1了 ","date":"2022-10-07","objectID":"/dr/:2:0","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"题解 ​ 官方： class Solution { public int maxAscendingSum(int[] nums) { int res = 0; int l = 0; while (l \u003c nums.length) { int cursum = nums[l++]; while (l \u003c nums.length \u0026\u0026 nums[l] \u003e nums[l - 1]) { cursum += nums[l++]; } res = Math.max(res, cursum); } return res; } } 我的： class Solution { public int maxAscendingSum(int[] nums) { int max = -1; int len = nums.length; for(int i=0; i\u003clen; i++) { int count = 0; while(i\u003clen-1 \u0026\u0026 nums[i] \u003c nums[i+1]){ count += nums[i]; i++; } // if(i==len-1 \u0026\u0026 len!=1 \u0026\u0026 nums[i] \u003e nums[i-1]){ // count += nums[i]; // } count += nums[i]; if(count \u003e max){ max = count; } } return max; } } ","date":"2022-10-07","objectID":"/dr/:3:0","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":" 最大升序数组和 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/:0:0","tags":null,"title":"Dr","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/"},{"categories":null,"content":"题目 给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。 子数组是数组中的一个连续数字序列。 已知子数组 [numsl, numsl+1, …, numsr-1, numsr] ，若对所有 i（l \u003c= i \u003c r），numsi \u003c numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。 示例 1： 输入：nums = [10,20,30,5,10,50] 输出：65 解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。 示例 2： 输入：nums = [10,20,30,40,50] 输出：150 解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 示例 3： 输入：nums = [12,17,15,13,10,11,12] 输出：33 解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 示例 4： 输入：nums = [100,10,1] 输出：100 提示： 1 \u003c= nums.length \u003c= 100 1 \u003c= nums[i] \u003c= 100 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/:1:0","tags":null,"title":"Dr","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/"},{"categories":null,"content":"分析 首先要注意临界条件，是从第一个开始临界最后还是从第二个开始临界第一个呢？ 因为最大数组的临界和最后一个的临界可能会在一起（），所以把临界放到最前面 又因为单个的数也可能算作最大数组，因此第一个刚好可以作为初始化max的值 注意用while循环求数组和的时候最后一个无论如何都是要加的，所以最后不用再判断i是否是nums.length-1了 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/:2:0","tags":null,"title":"Dr","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/"},{"categories":null,"content":"题解 ​ 官方： class Solution { public int maxAscendingSum(int[] nums) { int res = 0; int l = 0; while (l \u003c nums.length) { int cursum = nums[l++]; while (l \u003c nums.length \u0026\u0026 nums[l] \u003e nums[l - 1]) { cursum += nums[l++]; } res = Math.max(res, cursum); } return res; } } 我的： class Solution { public int maxAscendingSum(int[] nums) { int max = -1; int len = nums.length; for(int i=0; i\u003clen; i++) { int count = 0; while(i\u003clen-1 \u0026\u0026 nums[i] \u003c nums[i+1]){ count += nums[i]; i++; } // if(i==len-1 \u0026\u0026 len!=1 \u0026\u0026 nums[i] \u003e nums[i-1]){ // count += nums[i]; // } count += nums[i]; if(count \u003e max){ max = count; } } return max; } } ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/:3:0","tags":null,"title":"Dr","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dr/"},{"categories":null,"content":" Part1：栈 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"1、基本方法 1 Boolean empty测试堆栈是否为空。 2 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。 3 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object element) 把项压入堆栈顶部。 5 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"2、关于static ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"无法从static上下文引用非static变量 ​ 即：不能在static方法里调用没有static修饰的东西。因为你还没new对象哪来的不带static的成员和方法。而static优先于类加载，所以可以提前使用。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:1","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"静态变量不随这函数调用而改变 静态变量不是说不能修改，不能修改的是常量。它的值是可变的，并且会保持最新的值。说其静态，是因为它不会随着函数的调用和退出而发生变化，即上次你调函数它是什么样，这次还是什么样。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:2","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"3、堆栈方法区内存分析 stack（栈） 存放基本类型的数据和对象的引用，即存放变量。 如果存放的是基本类型数据（非静态变量），则直接将变量名和值存入stack中的内存中； 如果是引用类型，则将变量名存入栈，然后指向它new出的对象（存放在堆中）。 heap（堆） 存放new产生的数据。 data segment 也叫作方法区 分为静态域和常量域。 静态域 存放在对象中用static定义的静态成员（即静态变量，同理，如果该静态变量是基本类型则将变量名和值存入静态域，如果是引用类型则指向new出的对象）。 常量池 存放具体的值，也就是变量所代表的值 。 code segment 存放代码。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":" Part1：栈 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"1、基本方法 1 Boolean empty测试堆栈是否为空。 2 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。 3 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object element) 把项压入堆栈顶部。 5 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"2、关于static ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"无法从static上下文引用非static变量 ​ 即：不能在static方法里调用没有static修饰的东西。因为你还没new对象哪来的不带static的成员和方法。而static优先于类加载，所以可以提前使用。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:1","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"静态变量不随这函数调用而改变 静态变量不是说不能修改，不能修改的是常量。它的值是可变的，并且会保持最新的值。说其静态，是因为它不会随着函数的调用和退出而发生变化，即上次你调函数它是什么样，这次还是什么样。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:2","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"3、堆栈方法区内存分析 stack（栈） 存放基本类型的数据和对象的引用，即存放变量。 如果存放的是基本类型数据（非静态变量），则直接将变量名和值存入stack中的内存中； 如果是引用类型，则将变量名存入栈，然后指向它new出的对象（存放在堆中）。 heap（堆） 存放new产生的数据。 data segment 也叫作方法区 分为静态域和常量域。 静态域 存放在对象中用static定义的静态成员（即静态变量，同理，如果该静态变量是基本类型则将变量名和值存入静态域，如果是引用类型则指向new出的对象）。 常量池 存放具体的值，也就是变量所代表的值 。 code segment 存放代码。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"The first passage with the first hugoBlog 简单书写一些内容，纪念我的第一篇博客。 ","date":"2022-10-01","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"}]