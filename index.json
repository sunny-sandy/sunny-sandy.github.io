[{"categories":null,"content":"10/7最大升序数组和 ","date":"2022-10-07","objectID":"/dr/:1:0","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"题目 给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。 子数组是数组中的一个连续数字序列。 已知子数组 [numsl, numsl+1, …, numsr-1, numsr] ，若对所有 i（l \u003c= i \u003c r），numsi \u003c numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。 示例 1： 输入：nums = [10,20,30,5,10,50] 输出：65 解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。 示例 2： 输入：nums = [10,20,30,40,50] 输出：150 解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 示例 3： 输入：nums = [12,17,15,13,10,11,12] 输出：33 解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 示例 4： 输入：nums = [100,10,1] 输出：100 提示： 1 \u003c= nums.length \u003c= 100 1 \u003c= nums[i] \u003c= 100 ","date":"2022-10-07","objectID":"/dr/:1:1","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"分析 首先要注意临界条件，是从第一个开始临界最后还是从第二个开始临界第一个呢？ 因为最大数组的临界和最后一个的临界可能会在一起（），所以把临界放到最前面 又因为单个的数也可能算作最大数组，因此第一个刚好可以作为初始化max的值 注意用while循环求数组和的时候最后一个无论如何都是要加的，所以最后不用再判断i是否是nums.length-1了 ","date":"2022-10-07","objectID":"/dr/:1:2","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"题解 ​ 官方： class Solution { public int maxAscendingSum(int[] nums) { int res = 0; int l = 0; while (l \u003c nums.length) { int cursum = nums[l++]; while (l \u003c nums.length \u0026\u0026 nums[l] \u003e nums[l - 1]) { cursum += nums[l++]; } res = Math.max(res, cursum); } return res; } } 我的： class Solution { public int maxAscendingSum(int[] nums) { int max = -1; int len = nums.length; for(int i=0; i\u003clen; i++) { int count = 0; while(i\u003clen-1 \u0026\u0026 nums[i] \u003c nums[i+1]){ count += nums[i]; i++; } // if(i==len-1 \u0026\u0026 len!=1 \u0026\u0026 nums[i] \u003e nums[i-1]){ // count += nums[i]; // } count += nums[i]; if(count \u003e max){ max = count; } } return max; } } ","date":"2022-10-07","objectID":"/dr/:1:3","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"10/8优势洗牌 ","date":"2022-10-07","objectID":"/dr/:2:0","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"题目 给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] \u003e nums2[i] 的索引 i 的数目来描述。 返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。 示例 1： 输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11] 输出：[2,11,7,15] 示例 2： 输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11] 输出：[24,32,8,12] 提示： 1 \u003c= nums1.length \u003c= 105 nums2.length == nums1.length 0 \u003c= nums1[i], nums2[i] \u003c= 109 ","date":"2022-10-07","objectID":"/dr/:2:1","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"分析 首先，就是个首先，for里面前两个条件不能加什么布尔语句 for(int i\u003c0; i\u003clen /*\u0026\u0026 flag[i] != false*/; i++) { //java code } 如果你在前两个条件里面写这个，就会像 i==len时那样直接跳出循环，类似于break的用法，而不是你想得到的continue用法，切记切记 还有就是一旦题目设计了大数字问题，就要考虑时间复杂度不能使用平方形式，否则就会超时报错 这时就需要学习其他的省时的查找方法了 ","date":"2022-10-07","objectID":"/dr/:2:2","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":"题解 class Solution { public int[] advantageCount(int[] nums1, int[] nums2) { //使nums1[]的优势最大化 //对于某一个nums1[i]，先找nums2中的小于nums1[i]的最大的 //如果没有小于nums1[i]的，就拿nums2中的最大值 int len = nums1.length; int minIndex = 0;//找最小时候的起始点 int[] nums3 = new int[len];//以后返回值最好用ans boolean[] flag = new boolean[len]; Arrays.sort(nums1); for(int i=0; i\u003clen; i++) { int left = 0, right = len; //二分查找 找最小的大于 num2[i]的元素 while (left != right) { int mid = left + ((right - left) \u003e\u003e 1); if (nums1[mid] \u003c nums2[i]) { left = mid + 1; } else { right = mid; } } //在left \u003c n的大前提下，如果这个数已经被访问过了或者是相等的数(产生不了优势)，就必须让left++来选取更好的数 while (left \u003c len \u0026\u0026 (flag[left] || nums1[left] == nums2[i])) { left++; } //走到头了，没找到满足既未访问又大于的数 if (left == len) { //没有大于num[i]的元素，取最小的元素 while (flag[minIndex]) { minIndex++; } nums3[i] = nums1[minIndex]; flag[minIndex++] = true; } else { flag[left] = true; nums3[i] = nums1[left]; } } return nums3; } } ","date":"2022-10-07","objectID":"/dr/:2:3","tags":null,"title":"Dr","uri":"/dr/"},{"categories":null,"content":" Part1：栈 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"1、基本方法 1 Boolean empty测试堆栈是否为空。 2 Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。 3 Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 4 Object push(Object element) 把项压入堆栈顶部。 5 int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"2、关于static ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"无法从static上下文引用非static变量 ​ 即：不能在static方法里调用没有static修饰的东西。因为你还没new对象哪来的不带static的成员和方法。而static优先于类加载，所以可以提前使用。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:1","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"静态变量不随这函数调用而改变 静态变量不是说不能修改，不能修改的是常量。它的值是可变的，并且会保持最新的值。说其静态，是因为它不会随着函数的调用和退出而发生变化，即上次你调函数它是什么样，这次还是什么样。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:2","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"3、堆栈方法区内存分析 stack（栈） 存放基本类型的数据和对象的引用，即存放变量。 如果存放的是基本类型数据（非静态变量），则直接将变量名和值存入stack中的内存中； 如果是引用类型，则将变量名存入栈，然后指向它new出的对象（存放在堆中）。 heap（堆） 存放new产生的数据。 data segment 也叫作方法区 分为静态域和常量域。 静态域 存放在对象中用static定义的静态成员（即静态变量，同理，如果该静态变量是基本类型则将变量名和值存入静态域，如果是引用类型则指向new出的对象）。 常量池 存放具体的值，也就是变量所代表的值 。 code segment 存放代码。 ","date":"2022-10-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":null,"title":"数据结构","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"The first passage with the first hugoBlog 简单书写一些内容，纪念我的第一篇博客。 ","date":"2022-10-01","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"}]