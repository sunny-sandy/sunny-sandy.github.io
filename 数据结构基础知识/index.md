# 数据结构


---
## Part1：栈

### 1、基本方法

| 1    | Boolean  empty测试堆栈是否为空。                             |
| ---- | :----------------------------------------------------------- |
| 2    | Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。      |
| 3    | Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |
| 4    | Object push(Object element) 把项压入堆栈顶部。               |
| 5    | int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 |



### 2、关于static

#### 无法从static上下文引用非static变量

​	即：不能在static方法里调用没有static修饰的东西。因为你还没new对象哪来的不带static的成员和方法。而static优先于类加载，所以可以提前使用。

#### 静态变量不随这函数调用而改变

静态变量不是说不能修改，不能修改的是常量。它的值是可变的，并且会保持最新的值。说其静态，是因为**它不会随着函数的调用和退出而发生变化**，即上次你调函数它是什么样，这次还是什么样。

### 3、堆栈方法区内存分析

stack（栈）
    存放基本类型的数据和对象的引用，即存放变量。
    如果存放的是基本类型数据（非静态变量），则直接将变量名和值存入stack中的内存中；
    如果是引用类型，则将变量名存入栈，然后指向它new出的对象（存放在堆中）。

heap（堆）
   存放new产生的数据。

data segment 也叫作方法区
    分为静态域和常量域。

    静态域
    存放在对象中用static定义的静态成员（即静态变量，同理，如果该静态变量是基本类型则将变量名和值存入静态域，如果是引用类型则指向new出的对象）。
    
    常量池
    存放具体的值，也就是变量所代表的值 。

code segment
存放代码。

![20210121175003215](D:\pictures\屏幕截图\20210121175003215.png)



## Vector  ---> 引用传参和指针传参的区别

**引用参数传递**
引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

**引用传递和指针传递是不同的**
虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

**从编译的角度来讲**
程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

